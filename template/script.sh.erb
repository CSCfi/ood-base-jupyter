#!/usr/bin/env bash

# Prints $1 in log and app info card before cancelling slurm job and exiting with exit code $2.
exit_verbose() {
  echo "$1" | tee "<%= session.staged_root.join("job_exit_reason") -%>"
  scancel "$SLURM_JOB_ID"
  exit "${2:-0}"
}

# Benchmark info
echo "TIMING - Starting main script at: $(date)"

# Set working directory to home directory
cd "${HOME}"

<% if context.advanced == "1" %>
  <% if context.env_script == "Text" %>
    echo "Running user-provided script"
    <%= context.custom_start %>
  <% elsif context.env_script == "File" %>
    echo "Sourcing <%= context.custom_script %>"
    source "<%= context.custom_script %>"
  <% end %>
<% else %>
# Probably not safe on lumi
#  module purge

echo "Using python from"
  which python
  python="python"
  <% if context.python_module == "Custom" -%>
    python_path="<%= context.custom_python_path %>"
    if [[ -f "$python_path" && -x "$python_path" ]]; then
    # User provided full path to python executable
      python="$python_path"
      export PATH="$(dirname "$python_path"):$PATH"
    elif [[ -d $python_path && "$(basename "$python_path")" = "bin" ]]; then
      # User provided a path to a bin directory with a python executable
      export PATH="$python_path:$PATH"
      if [[ "$(dirname "$(command -v python)")" = "${python_path%%/}" ]]; then
        python="$(command -v python)"
      else
        # User provided a bin path but no python was found
        # TODO: allow python3 binary instead of just python?
        exit_verbose "Python not found in provided path" 1
      fi
    else
      # User provided something that wasn't either a path to python binary or bin directory
      # TODO: attempt to load module here?
      exit_verbose "Unknown python path provided" 1
    fi
  <%- else -%>
    module load <%= context.python_module %>
  <%- end -%>

  # List loaded modules
  module list

  venv="<%= context.venv -%>"
  venv="${venv%/bin/activate}"
  if [ ! -z "$venv" ]; then
    if [[ -f "$venv/bin/activate" ]]; then
      echo "Activating venv at $venv"
      source "$venv/bin/activate"
      unset python
    else
      echo "Creating new venv at $venv"

      # --system-site-packages does not work properly with the module system
      # packages from the module are added if module is loaded when activating venv
      error_msg=$($python -m venv "$venv" <%= "--system-site-packages" if context.system_site == "1" -%> 2>&1 > /dev/null)
      return_code="$?"
      if [[ ! "$return_code" -eq 0 ]];then
        exit_verbose "Could not create venv: $error_msg" 1
      fi

      echo "Activating created venv at $venv"

      source "$venv/bin/activate"
      unset python

      # Set PYTHONNOUSERSITE already to avoid accidentally installing into user packages if venv is not writable.
      <% if context.user_packages == "0" -%>
      export PYTHONNOUSERSITE="TRUE"
      <% end -%>

      # Install jupyterlab if there is no jupyter installed (system python only)
      if [[ ! $(command -v jupyter) ]]; then
        echo "Installing jupyterlab"
        python -m pip install jupyterlab
      fi

      # Install kernel that points to the venv python
      python -m ipykernel install --prefix="$venv" --name="python3" --display-name="Python 3"
    fi

    # Set JUPYTER_DATA_DIR to find kernels from this venv
    export JUPYTER_DATA_DIR="$venv/share/jupyter"
    <% if context.user_packages == "0" -%>
      echo "Disabling user packages"
      export PYTHONNOUSERSITE="TRUE"
      if ! $(PYTHONNOUSERSITE="TRUE" python -c 'import jupyter' > /dev/null 2>&1); then
        if $(unset PYTHONNOUSERSITE; python -c 'import jupyter' > /dev/null 2>&1); then
          echo "Jupyter is installed only in user packages but user packages are disabled"
        else
          echo "Jupyter is not installed"
        fi
      fi
    <% end -%>
  fi

  # Some modules don't have the extensions enabled, enable them for user
  ${python:-python} -m jupyter server extension enable --user --py nbclassic
  ${python:-python} -m jupyter server extension enable --user --py jupyterlab
<% end %>

# Benchmark info
echo "TIMING - Starting jupyter at: $(date)"
# Launch the Jupyter Notebook Server
set -x
${python:-python} -m jupyter $jp_type --config="${CONFIG_FILE}"
